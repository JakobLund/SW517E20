# SW517e20

## General

### Naming conventions

The naming of different components follow the Python naming conventions, which can be seen [here](https://www.python.org/dev/peps/pep-0008/), which has been boiled down [here](https://visualgit.readthedocs.io/en/latest/pages/naming_convention.html).

## Unit testing
The unit tests for the project are structured according to the _pytest_ documentation found [here](https://docs.pytest.org/en/stable/contents.html#toc).

### Setup
To set up _pytest_ in you virtual environment, you should add _pytest==6.1.1_ to the _requirements.txt_ for the module, if not already present, and then set the testing framework to _pytest_. In PyCharm, this is done under _settings > Tools > Python Integrated Tools_.

The folder structure of the tests is _{module\_folder} > unitTests > {test\_ClassToBeTested}_.

### Defining tests

A test is defined as seen below:

	def test_{method_name}_{what_should_happen_given_input}:
		assert method(param)

To speed up the process of creating tests, some IDE's can generate the tests for an entire class or a specific method.

The tests for a given file/class is grouped in a file named '_test\_{name\_of\_file/class}.py_'. The class within the file should follow _Test{TestedClass}_. Each of the test files can have specialized _setUp_ and _tearDown_ methods as seen below:

	def setup_method(self, method):
		""" setup any state tied to the execution of the given method in a
		class.  setup_method is invoked for every test method of a class.
		"""

	...

	{tests}

	...


	def teardown_method(self, method):
		""" teardown any state that was previously setup with a setup_method
		call.
		"""

The _setup\_method_ method is used to avoid duplicate set up code for the tests in the file, as they often use similar or identical prerequisite data, such as initialized objects. The _teardown\_method_ is used to dispose of any objects or structures that otherwise could be left behind as garbage.

### (Mocking)

### (Test suite)
It is also possible to set up test suites as well, allowing us to set the execution order for the tests and add conditions for what test to be executed.

## Virtual environment

The virtual environment should just be set up for each module, as it should never be necessary to duplicate in other modules with other dependencies. However, the requirements for the virtual environment should be exported to the _requirements.txt_ file and this file should then be loaded when ever the given module is being set up.

> :info: Remember to activate your virtual environment by running `source venv/bin/activate`.

### Handling requirements.txt

The _requirements.txt_ file can be generated by running the command:

    pip freeze -l > requirements.txt

It can then be loaded into the current project by running the command:

    pip install -r requirements.txt

If _conda_ is used, it is necessary to install _pip_ in the virtual environment to use these commands. This is, from our research during the project, the easiest way to handle requirements in _conda_.

> :warning: _pip_ might be switched out for _pip3_ on your system

### Generate packages
```
https://packaging.python.org/tutorials/packaging-projects/
https://packaging.python.org/guides/hosting-your-own-index/
```
